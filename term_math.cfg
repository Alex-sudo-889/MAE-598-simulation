# Live 2D Robot Sim — Control Term Equations
#
# Edit this file to tweak the velocity contributions using pure math expressions.
# Each section defines one term.  When you press "Save + reload" inside the sim
# the engine compiles these to expressions *and* exports term_config.json so you
# can share ready-to-load presets.  Keys:
#   type        = single | obstacle | robots | potential
#   label       = UI label
#   description = UI tooltip text
#   active      = true/false toggle at startup
#   weight      = initial slider weight (0-2)
#   vx, vy      = expressions for the x/y velocity contribution (single/obstacle/robots)
#   condition   = optional boolean expression (obstacle/robots) to gate contributions
#   potential   = scalar field expression (for type=potential) — vx/vy ignored
#   Other keys  = constants available inside the expressions (e.g., k=1.2)
#
# Common variables made available:
#   single:   x, y, idx, goal_x, goal_y, goal_dx, goal_dy, goal_dist,
#             xmin, xmax, ymin, ymax, dist_left, dist_right, dist_top, dist_bottom,
#             num_robots, num_targets, num_obstacles
#   obstacle: (plus single vars) ob_x, ob_y, radius, dx, dy, dist
#   robots:   (plus single vars) other_x, other_y, other_idx, other_radius, dx, dy, dist, sum_radius
#   potential: same as single; use constants for shaping the field
#
# Maths helpers: sin, cos, tan, atan2, sqrt, exp, log, pow, abs, min, max, clamp.
# Booleans behave like 0/1 so (dist < radius) * value works fine.

[go_to]
type = single
label = Go To
description = Disabled (no waypoint attraction)
active = false
weight = 0.0
vx = 0.0
vy = 0.0

[coverage_density]
type = potential
label = Coverage Field
description = Disabled demand field (uniform coverage)
active = false
weight = 0.0
potential = 0.0

[frontier_flow]
type = single
label = Frontier Push
description = Global drift from staging edge toward uncovered frontier
active = true
weight = 0.9
vx = flow_gain * clamp(1.0 - ((x - base_x) / max((xmax - xmin), 1.0)), 0.0, 1.0)
vy = 0.0
flow_gain = 40.0
base_x = 170.0

[base_link]
type = single
label = Base Anchor
description = Keeps a designated robot locked to the base perimeter
active = true
weight = 0.9
vx = (idx == base_guard_idx) * (-anchor_gain) * ((sqrt((x - base_x)**2 + (y - base_y)**2) - (base_radius + coverage_radius)) * ((x - base_x) / max(sqrt((x - base_x)**2 + (y - base_y)**2), 1.0)))
vy = (idx == base_guard_idx) * (-anchor_gain) * ((sqrt((x - base_x)**2 + (y - base_y)**2) - (base_radius + coverage_radius)) * ((y - base_y) / max(sqrt((x - base_x)**2 + (y - base_y)**2), 1.0)))
base_radius = 260.0
base_x = 170.0
base_y = 380.0
anchor_gain = 1.4
base_guard_idx = 0.0

[base_cover]
type = single
label = Base Coverage Buffer
description = Repels robots when they overlap the base coverage disc
active = true
weight = 1.0
vx = (1.0 - (idx == base_guard_idx)) * (sqrt((x - base_x)**2 + (y - base_y)**2) < base_cover_radius) * rep_gain * ((x - base_x) / max(sqrt((x - base_x)**2 + (y - base_y)**2), 1.0))
vy = (1.0 - (idx == base_guard_idx)) * (sqrt((x - base_x)**2 + (y - base_y)**2) < base_cover_radius) * rep_gain * ((y - base_y) / max(sqrt((x - base_x)**2 + (y - base_y)**2), 1.0))
base_cover_radius = 260.0
base_x = 170.0
base_y = 380.0
base_guard_idx = 0.0
rep_gain = 120.0



[avoid_obs]
type = obstacle
label = Avoid Obst
description = Hard wall push near obstacles
active = true
weight = 0.9
vx = (dist < radius + infl) * k * (dx / (dist + soft_dir)) / ((max(dist - radius, 0.0) + soft_gap)**2)
vy = (dist < radius + infl) * k * (dy / (dist + soft_dir)) / ((max(dist - radius, 0.0) + soft_gap)**2)
condition = dist < radius + infl
k = 320000.0
infl = 120.0
soft_dir = 1.0
soft_gap = 6.0

[avoid_robots]
type = robots
label = Separation
description = Coverage-aware separation (inverse-square push)
active = true
weight = 1.1
vx = k * exp(-max(dist - max(sum_radius + body_margin, (coverage_radius + other_coverage_radius) * spacing_scale), 0.0) / rep_decay) * (dx / max(dist, 1.0)) / max((coverage_radius + other_coverage_radius), 1.0)
vy = k * exp(-max(dist - max(sum_radius + body_margin, (coverage_radius + other_coverage_radius) * spacing_scale), 0.0) / rep_decay) * (dy / max(dist, 1.0)) / max((coverage_radius + other_coverage_radius), 1.0)
condition = dist < (max(sum_radius + body_margin, (coverage_radius + other_coverage_radius) * spacing_scale) + rep_margin)
k = 640000.0
rep_decay = 14.0
rep_margin = 8.0
spacing_scale = 1.0
body_margin = 10.0

[chain_tension]
type = robots
label = Chain Tension
description = Maintains communication-distance contact between neighbors
active = true
weight = 0.85
vx = neighbor_gate * chain_gain * clamp(((coverage_radius + other_coverage_radius) - dist) / max((coverage_radius + other_coverage_radius), 1.0), -1.0, 1.0) * (dx / max(dist, 1.0))
vy = neighbor_gate * chain_gain * clamp(((coverage_radius + other_coverage_radius) - dist) / max((coverage_radius + other_coverage_radius), 1.0), -1.0, 1.0) * (dy / max(dist, 1.0))
chain_gain = 120.0

[obstacle_slide]
type = obstacle
label = Obstacle Slide
description = Adds tangential drift to steer robots around obstacles
active = true
weight = 0.4
vx = slide_gain * (((y >= base_y) * 2.0 - 1.0)) * (-(dy) / max(dist, 1.0)) * (dist < radius + slide_margin)
vy = slide_gain * (((y >= base_y) * 2.0 - 1.0)) * (dx / max(dist, 1.0)) * (dist < radius + slide_margin)
slide_gain = 240.0
slide_margin = 80.0
base_y = 380.0

[global_spread]
type = single
label = Global Spread
description = Slow drift toward uncovered frontier while respecting base radius
active = true
weight = 0.35
vx = spread_gain * clamp((x - base_x) / max((xmax - xmin), 1.0), 0.0, 1.0)
vy = spread_gain * clamp(((y - ((ymax + ymin) / 2.0)) / max((ymax - ymin), 1.0)), -0.6, 0.6)
spread_gain = 35.0
base_x = 170.0
[bounds]
type = single
label = Bounds
description = Push inward near world edges
active = true
weight = 0.6
vx = (dist_left < margin) * k * (margin - dist_left) / margin - (dist_right < margin) * k * (margin - dist_right) / margin
vy = (dist_bottom < margin) * k * (margin - dist_bottom) / margin - (dist_top < margin) * k * (margin - dist_top) / margin
k = 260.0
margin = 80.0

[phi]
type = potential
label = Phi
description = Gradient descent on custom potential field
active = false
weight = 0.3
potential = (x - cx)**2 + (y - cy)**2
cx = 0.0
cy = 0.0

[swirl]
type = single
label = Swirl Field
description = Example custom term that orbits the world center
active = false
weight = 0.4
vx = swirl_gain * (-(y - cy))
vy = swirl_gain * (x - cx)
# World center offsets (update if scene bounds change)
cx = 540.0
cy = 380.0
swirl_gain = 0.04
